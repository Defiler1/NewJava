<h1> Ch7

<h2>

- 상속
  - A 는 B 이다(is-a)
  - 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
  - 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)
  - 자바는 단일 상속만 가능함(다른 언어는 다중상속 가능)(인터페이스를 사용하면 다중상속과 같은 기능 구현 가능)
- 포함관계
  - A 는 B를 가지고 있다.(has-a)
  - 클래스의 멤버로 참조변수를 선언하는 것
  - 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.
- Object 클래스
  - 모든 클래스의 조상
  - 부모가 없는 클래스는 자동적으로(자바 컴파일러에 의해) Object클래스를 상속 받는다.
  - 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속 받는다.(toString(), equals(), hashCode()등)
- 오버라이딩(Overring)
  - 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
  - 메서드의 선언부는 변경불가, 구현부{}만 변경가능
- 오버라이딩의 조건
  - 선언부가 조상 클래스의 메서드와 일치해야 한다.
  - 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
  - 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 참조변수 super
  - 객체 자신을 가리키는 참조변수 
  - 인스턴스 메서드(생성자)내에만 존재
  - 조상의 멤버를 자신의 멤버와 구별할 때 사용
- super()
  - 조상의 생성자   
  - 조상의 생성자를 호출할 때 사용
  - 조상의 멤버는 조상의 생성자를 호출해서 초기화
  - 생성자의 첫 줄에 반드시 생성자를 호출해야 한다.
  - 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입함
- 패키지(package)
  - 서로 관련된 클래스의 묶음
  - 클래스는 클래스 파일, 패키지는 폴더. 하위 패키지는 하위 폴더
  - 클래스의 실제 이름은 패키지를 포함.(java.lang.String)
  - rt.jar는 클래스들을 압축한 파일 (java9부터 없어짐)
  - 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
  - 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
  - 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.
- 클래스 패스(class path)
  - 클래스 파일의 위치를 알려주는 경로
  - 환경변수 classpath로 관리하며, 경로간의 구분자는 ';'를 사용
  - classpath(환경변수)에 패키지의 루트를 등록해줘야 함.
- import 문
  - 클래스를 사용할 때 패키지이름을 생략할 수 있다.
  - 컴파일러에게 클래스가 속한 패키지를 알려준다.
  - java.lang패키지의 클래스는 import하지 않고도 사용할 수 있다.
  - String, Object, System, Thread 등
  - import문은 패키지문과 클래스선언 사이에 선언한다.
- static import문
  - static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
- 제어자(modifier)
  - 클래스와 클래스의 멤버에 부가적인 의미 부여
  - 접근 제어자
    - public, protected, default, private
  - 그 외
    - static, final, abstract, native 등
  - 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)
  - abstract   -  추상의, 미완성의
    - 추상 클래스 -  추상 메서드를 포함한 클래스
    - 추상 메서드 -  구현부가 없는 메서드
  - 접근 제어자(access modifier)
    - private  같은 클래스 내에서만 접근이 가능하다.
    - default 같은 패키지 내에서만 접근이 가능하다.
    - protected 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
    - public 접근 제한이 전혀 없다.
    - 사용이유 -  외부로부터 데이터를 보호하기 위해서
- 다형성(polymorphism)
  - 여러 가지 형태를 가질 수 있는 능력
  - 조상 타입 참조변수로 자손타입 객체를 다루는 것
  - 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
- 참조변수의 형변환
  - 사용할 수 있는 멤버의 갯수를 조절하는 것
  - 조상 자손 관계의 참조변수는 서로 형변환 가능
  - 조상 타입으로 형변환 할땐 생략가능
  - 자손의 타입으로 형변환 할땐 생략 불가
  - 상속관계가 아닌 클래스 간의 형변환 불가
- instanceof 연산자
  - 참조변수의 형변환 가능여부 확인에 사용, 가능하면 true반환
  - 형변환 전에 반드시 instanceof로 확인해야 함
- 매개변수의 다형성
  - 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
- 여러 종류의 객체를 배열로 다루기
  - 조상타입의 배열에 자손들의 객체를 담을 수 있다.
- 추상클래스(abstract class)
  - 미완성 설계도, 미완성 메서드를 갖고 있는 클래스
  - 다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가
  - 상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능
  - 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.
- 추상메서드(abstract method)
  - 미완성 메서드
  - 구현부{}가 없는 메서드
  - 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우 사용
  - 추상 메서드 호출 가능(호출할 때는 선언부만 필요)
- 인터페이스(interface)
  - 추상 메서드의 집합
  - 구현된 것이 전혀 없는 설계도(모든 멤버가 public)
  - 인터페이스 안의 추상 메서드를 작성할 때 public static은 생략가능(항상 public static 이기 때문에)
  - 상수도 항상 public static final을 작성하기 때문에 생략가능
- 인터페이스의 상속
  - 인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상 아님)
  - 다중 상속 가능(추상 메서드는 충돌해도 문제 없음)
- 인터페이스의 구현
  - 인터페이스에 정의된 추상 메서드를 완성하는 것
  - class 클래스명 implements 인터페이스명 {인터페이스에 정의된 모든 추상메서드를 구현해야 함}
  - 일부만 구현하는 경우 클래스 앞에 abstract를 붙여야 함.
- 인터페이스를 이용한 다형성
  - 인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능
  - 인터페이스를 메서드의 리턴 타입으로 지정할 수 있다.
- 인터페이스의 장점
  - 두 대상(객체) 간의 연결, 대화, 소통을 돕는 중간 역할을 한다.
  - 선언(설계)와 구현을 분리시킬 수 있게 한다.
  - 개발 시간을 단축할 수 있다.
  - 변경에 유리한 유연한 설계가 가능하다.
  - 표준화가 가능하다.(JDBC)
  - 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.
- 디폴트 메서드와 static 메서드
  - 인터페이스에 디폴트 메서드, static메서드 추가 가능(jdk1.8부터)
  - 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움
  - 디폴트 메서드는 인스턴스 메서드(인터페이스 원칙 위반(예외))
  - 디폴트 메서드가 기존의 메서드와 충돌할 때의 해결책
    - 1 여러 인터페이스의 디폴트 메서드 간의 충돌
    - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 함
    - 2 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
- 내부 클래스(inner class)
  - 클래스 안의 클래스
  - 장점
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
    - 코드의 복잡성을 줄일 수 있다.(캡슐화)
- 익명 클래스(anonymous class)
  - 이름이 없는 일회용 클래스
  - 정의와 생성을 동시에 함
  - 