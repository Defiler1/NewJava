<h1>

Ch11

<h2>

- 컬렉션(collection)
  - 여러 객체(데이터)를 모아 놓은 것
- 프레임워크(framework)
  - 표준화, 정형화된 체계적인 프로그래밍 방식
  - 프레임워크를 사용하면 유지, 보수가 쉬워짐
- 컬렉션 프레임워크
  - 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
  - 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
  - java.util패키지에 포함 jdk1.2부터 제공
- 컬렉션 클래스(collection class)
  - 다수의 데이터를 저장할수 있는 클래스(예, Vector, ArrayList, HashSet)
- 컬렉션
  - List
    - 순서가 있는 데이터의 집합
    - 데이터의 중복을 허용한다.
    - ArrayList, LinkedList, Stack, Vector등
      - ArrayList
        - ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
        - ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
        - List인터페이스를 구현하므로, 저장순서 유지, 중복허용
        - 데이터의 저장공간으로 배열을 사용한다.(배열기반) 
      - 배열의 장단점
      - 장점  - 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간, access time)이 짧다.
      - 단점  - 크기를 변경할 수 없다.
      - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함.
      - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨
      - 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
      - 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.
      - LinkedList  - 배열의 단점을 보완
      - 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link)
      - 데이터 접근성이 나쁨
      - Doubly linked list  - 이중 연결리스트, 접근성 향상
      - linked list의 단점을 보완
      - Doubly circular linked list - 이중 원형 연결리스트
      - 첫번째 요소의 이전 요소로 이동시 마지막 요소로 이동
      - ArrayList 와 LinkedList 성능비교
        - 순차적 데이터 추가/삭제 - ArrayList가 빠름
        - 비순차적 데이터 추가/삭제 - LinkedList가 빠름
        - 접근시간(access time) - ArrayList가 빠름 
  - Set
    - 순서를 유지하지 않는 데이터의 집합
    - 데이터의 중복을 허용하지 않는다.
    - HashSet, TreeSet등
  - Map
    - 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합
    - 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용함.
    - HashMap, TreeMap, Hashtable, Properties등
- Stack & Queue
  - 스택
    - LIFO(last in first out)구조, 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
    - 저장(push), 추출(pop)
    - 배열 구현에 효율적
    - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로 앞으로 버튼구현 등 에 활용
  - 큐
    - FIFO(first in first out)구조, 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
    - 저장(offer), 추출(poll)
    - 링크드리스트 구현에 효율적
    - 자바에서 큐는 인터페이스로 정의되어 있음
    - 큐 사용법
      - 큐를 직접구현
      - 큐를 구현한 클래스를 사용
    - 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer) 구현 등 에 활용
- Iterator, ListIterator, Enumeration
  - 컬렉션에 저장된 데이터를 접근 하는데 사용되는 인터페이스
  - Enumeration은 Iterator의 구버전
  - ListIterator는 Iterator의 접근성을 향상시킨 것(단방향 -> 양방향)
  - 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것
  - 컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용
  - Map에는 iterator()가 없다.
  - Map은 keySet(), entrySet(), values()를 호출해야 함
- Arrays클래스
  - 배열을 다루기 편리한 메서드(static) 제공
  - 배열의 출력 - toString()
  - 배열의 복사 - copyOf(), copyOfRange(), System.arraycopy(arr1, arr2)
  - Arrays.copyOf(arr, arr.length)
    - arr 배열을 arr.length만큼 복사 해서 새로운 배열 생성 arr.length자리에 arr.length이상의 수가 오면 배열에 0으로 채워줌
  - Arrays.copyOfRange(arr, from, to)
    - arr배열을 from부터 to까지 복사함 (to는 미포함)
  - 배열 채우기 - fill(), setAll()
  - Arrays.fill(arr, 9)
    - arr배열을 9로 채움
  - Arrays.setAll(arr, 람다식)
    - 람다식을 이용하여 arr배열을 채움
  - 배열의 정렬과 검색  - sort(), binarySearch()
  - Arrays.binarySearch(arr, 2)
    - 배열에서 숫자 2의 인덱스 번호 반환
    - 이진탐색은 배열이 정렬되어 있을 때만 가능함
  - Arrays.sort(arr)
    - 배열을 오름차순으로 정렬
  - 다차원 배열의 출력  - deepToString()
  - 다차원 배열의 비교  - deepEquals()
  - 배열을 List(읽기전용)로 변환  - asList(가변 매개변수)
  -  