<h1>

Ch11

<h2>

- 컬렉션(collection)
  - 여러 객체(데이터)를 모아 놓은 것
- 프레임워크(framework)
  - 표준화, 정형화된 체계적인 프로그래밍 방식
  - 프레임워크를 사용하면 유지, 보수가 쉬워짐
- 컬렉션 프레임워크
  - 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
  - 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
  - java.util패키지에 포함 jdk1.2부터 제공
- 컬렉션 클래스(collection class)
  - 다수의 데이터를 저장할수 있는 클래스(예, Vector, ArrayList, HashSet)
- 컬렉션
  - List
    - 순서가 있는 데이터의 집합
    - 데이터의 중복을 허용한다.
    - ArrayList, LinkedList, Stack, Vector등
      - ArrayList
        - ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
        - ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
        - List인터페이스를 구현하므로, 저장순서 유지, 중복허용
        - 데이터의 저장공간으로 배열을 사용한다.(배열기반) 
      - 배열의 장단점
      - 장점  - 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간, access time)이 짧다.
      - 단점  - 크기를 변경할 수 없다.
      - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함.
      - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨
      - 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
      - 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.
      - LinkedList  - 배열의 단점을 보완
      - 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link)
      - 데이터 접근성이 나쁨
      - Doubly linked list  - 이중 연결리스트, 접근성 향상
      - linked list의 단점을 보완
      - Doubly circular linked list - 이중 원형 연결리스트
      - 첫번째 요소의 이전 요소로 이동시 마지막 요소로 이동
      - ArrayList 와 LinkedList 성능비교
        - 순차적 데이터 추가/삭제 - ArrayList가 빠름
        - 비순차적 데이터 추가/삭제 - LinkedList가 빠름
        - 접근시간(access time) - ArrayList가 빠름 
  - Set
    - 순서를 유지하지 않는 데이터의 집합
    - 데이터의 중복을 허용하지 않는다.
    - HashSet, TreeSet등
  - Map
    - 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합
    - 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용함.
    - HashMap, TreeMap, Hashtable, Properties등
- Stack & Queue
  - 스택
    - LIFO(last in first out)구조, 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
    - 저장(push), 추출(pop)
    - 배열 구현에 효율적
    - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로 앞으로 버튼구현 등 에 활용
  - 큐
    - FIFO(first in first out)구조, 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
    - 저장(offer), 추출(poll)
    - 링크드리스트 구현에 효율적
    - 자바에서 큐는 인터페이스로 정의되어 있음
    - 큐 사용법
      - 큐를 직접구현
      - 큐를 구현한 클래스를 사용
    - 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer) 구현 등 에 활용
- Iterator, ListIterator, Enumeration
  - 컬렉션에 저장된 데이터를 접근 하는데 사용되는 인터페이스
  - Enumeration은 Iterator의 구버전
  - ListIterator는 Iterator의 접근성을 향상시킨 것(단방향 -> 양방향) (List를 구현한 경우만 사용가능)
  - 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것
  - 컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용
  - Map에는 iterator()가 없다.
  - Map은 keySet(), entrySet(), values()를 호출해야 함
- Arrays클래스
  - 배열을 다루기 편리한 메서드(static) 제공
  - 배열의 출력 - toString()
  - 배열의 복사 - copyOf(), copyOfRange(), System.arraycopy(arr1, arr2)
  - Arrays.copyOf(arr, arr.length)
    - arr 배열을 arr.length만큼 복사 해서 새로운 배열 생성 arr.length자리에 arr.length이상의 수가 오면 배열에 0으로 채워줌
  - Arrays.copyOfRange(arr, from, to)
    - arr배열을 from부터 to까지 복사함 (to는 미포함)
  - 배열 채우기 - fill(), setAll()
  - Arrays.fill(arr, 9)
    - arr배열을 9로 채움
  - Arrays.setAll(arr, 람다식)
    - 람다식을 이용하여 arr배열을 채움
  - 배열의 정렬과 검색  - sort(), binarySearch()
  - Arrays.binarySearch(arr, 2)
    - 배열에서 숫자 2의 인덱스 번호 반환
    - 이진탐색은 배열이 정렬되어 있을 때만 가능함
  - Arrays.sort(arr)
    - 배열을 오름차순으로 정렬
  - 다차원 배열의 출력  - deepToString()
  - 다차원 배열의 비교  - deepEquals()
  - 배열을 List(읽기전용)로 변환  - asList(가변 매개변수)
- Comparator  - 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용
- comparable  - 기본 정렬기준을 구현하는데 사용
  - compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성한다.
  - 같으면0, 오른쪽이 크면 음수, 작으면 양수
- HashSet
  - 순서 X, 중복 X
  - Set 인터페이스를 구현한 대표적인 컬렉션 클래스
  - 순서를 유지하려면  LinkedHashSet클래스를 사용하면 된다.
  - 객체를 저장하기전에 기존에 같은 객체가 있는지 확인
  - 같은 객체가 없으면 저장, 있으면 저장하지 않음
  - boolean add(Object o)는 저장할 객체의 equals()와 hashCode()를 호출
- TreeSet
  - 범위 검색과 정렬에 유리한 컬렉션 클래스
  - HashSet보다 데이터 추가, 삭제에 시간이 더 걸림
  - 이진 탐색 트리(binary search tree)로 구현, 범위 탐색과 정렬에 유리
  - 이진 트리는 모든 노드가 최대 2개(0~2개)의 하위 노드를 갖음
  - 각 요소(node)가 나무 형태로 연결(LinkedList의 변형)
- 이진 탐색 트리(binary search tree)
  - 부모보다 작은 값은 왼쪽 큰 값은 오른쪽에 저장
  - 데이터가 많아질 수록 추가, 삭제에 시간이 더 걸림(비교 횟수 증가)
  - 이진 트리의 한 종류
- 트리 순회(tree traversal)
  - 이진 트리의 모든 노드를 한번씩 읽는 것을 트리 순회라고 한다.
  - 전위, 중위, 후위 순회법이 있으며, 중위 순회하면 오름차순으로 정렬된다.
- HashMap과 Hashtable
  - 순서X, 중복(키X, 값O)
  - Map인터페이스를 구현, 데이터를 키와 값의 쌍으로 저장
  - HashMap(동기화x)은 Hashtable(동기화O)의 신버전
  - HashMap
    - Map인터페이스를 구현한 대표적인 컬렉션 클래스
    - 순서를 유지하려면, LinkedHashMap클래스를 사용하면 된다.
    - 해싱(hashing)기법으로 데이터를 저장, 데이터가 많아도 검색이 빠름
    - Map인터페이스르 구현, 데이터를 키와 값의 쌍으로 저장
    - key - 컬렉션 내의 key 중에서 유일해야 한다.
    - value - key와 달리 데이터의 중복을 허용한다.
    - hashing
      - 해쉬함수를 이용해서 저장 & 읽어오기
      - 해쉬함수로 해쉬테이블에 데이터를 저장 검색
    - hashtable
      - 배열과 링크드 리스트가 조합된 형태
- Collections
  - 컬렉션을 위한 메서드(static)를 제공
  - 컬렉션 채우기, 복사, 정렬, 검색 - fill(), copy(), sort(), binarySearch()등
  - 컬렉션의 동기화 - synchronizedXXX()
  - 변경불가(readOnly) 컬렉션 만들기  - unmodifialbeXXX()
  - 싱글톤 컬렉션 만들기  - singletonXXX()
  - 한 종류의 객체만 저장하는 컬렉션 만들기 - checkedXXX()
  - 